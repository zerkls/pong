#include <stdio.h> 

// Глобальные переменные для счета
int fPScore = 0; // Счет первого игрока (слева)
int sPScore = 0; // Счет второго игрока (справа)

// Прототипы функций
void cross_and_toe_display();
int f_board_key(char key, int fRStart, int fREnd, int min_pos_y, int max_pos_y);
int second_board_key(char key, int sRStart, int sREnd, int min_pos_y, int max_pos_y);

// --- Основная функция ---
int main(void) {
    // Бесконечный цикл, чтобы игра перезапускалась после каждой партии
    // (победы одного из игроков или выхода по 'q')
    while (1) {
        cross_and_toe_display(); // Вызываем функцию, которая управляет одной партией игры
    }
    return 0; // Эта строка никогда не будет достигнута из-за while(1)
}

// --- Основная функция отображения и логики игры ---
void cross_and_toe_display() {
    // --- Инициализация позиций и параметров ---
    // Позиции первой (левой) ракетки
    int fRStart = 5;      // Верхняя Y-координата ракетки
    int fREnd = 7;        // Нижняя Y-координата ракетки
    int firstRacketX = 3; // X-координата ракетки (фиксирована)

    // Позиции второй (правой) ракетки
    int sRStart = 17;     // Верхняя Y-координата ракетки
    int sREnd = 19;       // Нижняя Y-координата ракетки
    int secondRacketX = 76; // X-координата ракетки (фиксирована)

    // Символы для отрисовки
    char vertical = '|';   // Вертикальные границы и ракетки
    char horizontal = '-'; // Горизонтальные границы
    char space = ' ';      // Пустое пространство
    char point = '*';      // Мяч

    // Позиция и скорость мяча
    int pointX = 39;      // Начальная X-координата мяча (примерно по центру)
    int pointY = 12;      // Начальная Y-координата мяча (примерно по центру)
    int pointSpeedX = 1; // Скорость/направление мяча по X (1: вправо, -1: влево)
    int pointSpeedY = 1; // Скорость/направление мяча по Y (1: вниз, -1: вверх)

    // Размеры игрового поля (включая границы)
    int max_pos_y = 25; // Высота поля (строк)
    int max_pos_x = 80; // Ширина поля (столбцов)
    int min_pos_y = 1; // Минимальная Y-координата, доступная для движения ракеток (выше верхней границы)

    // Сброс счетов в начале новой игры/раунда
    fPScore = 0;
    sPScore = 0;

    // --- Начальная очистка экрана ---
    // Очистить поле
    printf("\033[0d\033[2J");

    int flag = 1; // Флаг для управления текущим раундом игры (1 = активен, 0 = завершен)

    // --- Основной игровой цикл (один раунд) ---
    while (flag) {
        printf("\033[0d\033[2J"); // Очищаем экран в начале каждого "кадра"

        // --- Отрисовка игрового поля без массива ---
        // Итерируем по каждой ячейке консоли и печатаем нужный символ
        for (int i = 0; i < max_pos_y; i++) { // Проходим по строкам (Y-координата)
            for (int j = 0; j < max_pos_x; j++) { // Проходим по столбцам (X-координата)
                // Определяем, какой символ должен быть в текущей ячейке (j, i)
                if (i == pointY && j == pointX) {
                    printf("%c", point); // Если это позиция мяча, печатаем мяч
                } else if ((i >= fRStart && i <= fREnd && j == firstRacketX) || (i >= sRStart && i <= sREnd && j == secondRacketX)) {
                    printf("%c", vertical); // Если это позиция ракетки, печатаем ракетку
                } else if (j == 0 || j == max_pos_x - 1) {
                    printf("%c", vertical); // Если это левая/правая граница, печатаем вертикальную черту
                } else if (i == 0 || i == max_pos_y - 1) {
                    printf("%c", horizontal); // Если это верхняя/нижняя граница, печатаем горизонтальную черту
                } else {
                    printf("%c", space); // Иначе печатаем пробел (пустое место)
                }
            }
            printf("%c", '\n'); // Переходим на новую строку после каждой строки игрового поля
        }

        // --- Логика отскока мяча от верхних/нижних границ ---
        // max_pos_y - 2 - это последняя доступная Y-координата перед нижней горизонтальной границей (max_pos_y - 1)
        // min_pos_y - это первая доступная Y-координата после верхней горизонтальной границы (0)
        if (pointY == max_pos_y - 2)
            pointSpeedY = -1; // Меняем направление на "вверх"
        if (pointY == min_pos_y)
            pointSpeedY = 1; // Меняем направление на "вниз"

        // --- Логика начисления очков и завершения партии ---
        if (pointX == max_pos_x - 1) { // Мяч достиг правой границы (промах второго игрока)
            fPScore++; // Первому игроку очко
            if (fPScore >= 20) { // Если первый игрок набрал 20 очков (условие победы)
                printf("Win First player!\n");
                flag = 0; // Устанавливаем флаг в 0, чтобы завершить раунд
                break;    // Выходим из цикла `while(flag)`
            }
            // Сброс мяча в центр для следующего очка
            pointX = max_pos_x / 2;
            pointY = max_pos_y / 2;
            pointSpeedX = -1; // Мяч летит в сторону игрока, который проиграл очко
            pointSpeedY = 1;
        }
        if (pointX == 0) { // Мяч достиг левой границы (промах первого игрока)
            sPScore++; // Второму игроку очко
            if (sPScore >= 20) {
                printf("Win Second player!\n");
                flag = 0; // Завершаем раунд
                break;
            }
            // Сброс мяча
            pointX = max_pos_x / 2;
            pointY = max_pos_y / 2;
            pointSpeedX = 1; // Мяч летит в сторону игрока, который проиграл очко
            pointSpeedY = 1;
        }

        // --- Логика отскока мяча от ракеток ---
        // Отскок от правой ракетки: мяч находится на 1 позицию левее ракетки, и Y-координата мяча попадает в диапазон ракетки
        if ((sRStart <= pointY && pointY <= sREnd && pointX == secondRacketX - 1))
            pointSpeedX = -1; // Меняем направление на "влево"
        // Отскок от левой ракетки: мяч находится на 1 позицию правее ракетки, и Y-координата мяча попадает в диапазон ракетки
        if (fRStart <= pointY && pointY <= fREnd && pointX == firstRacketX + 1)
            pointSpeedX = 1; // Меняем направление на "вправо"

        // --- Вывод счета и подсказок ---
        printf("Points First's player: %d\n", fPScore);
        printf("Points Second's player: %d\n", sPScore);
        printf("Controls: Player 1 (Move UP: 'a', Move DOWN: 'z'). Player 2 (Move UP: 'k', Move DOWN: 'm'). Press ENTER to move ball. Press 'q' to quit.\n");

        char key = getchar(); // Считываем ввод пользователя. Эта функция блокирует
                             // выполнение до тех пор, пока пользователь не нажмет клавишу И Enter.

        // Очищаем буфер ввода, чтобы избежать обработки лишних символов (например, '\n' от Enter)
        int c;
        while ((c = getchar()) != '\n' && c != EOF);

        // --- Обработка движения первой ракетки (левой) ---
        int f_move = f_board_key(key, fRStart, fREnd, min_pos_y, max_pos_y);
        if (f_move == 1) { // Движение вниз
            fRStart++;
            fREnd++;
        } else if (f_move == -1) { 
            fREnd--;
        }

        // --- Обработка движения второй ракетки (правой) ---
        int s_move = second_board_key(key, sRStart, sREnd, min_pos_y, max_pos_y);
        if (s_move == 1) { // Движение вниз
            sRStart++;
            sREnd++;
        } else if (s_move == -1) { 
            sREnd--;
        }

        // --- Выход из игры ---
        if (key == 'q' || key == 'Q') {
            printf("Exiting game. Final Score: Player 1: %d, Player 2: %d\n", fPScore, sPScore);
            flag = 0; // Завершаем текущий раунд
            break;    // Выходим из цикла раунда
        }

        // --- Движение мяча ---
        // Мяч движется только, если пользователь нажал Enter (или любой символ,
        // за которым последовал Enter, и `key` стал '\n' после очистки буфера)
        if (key == '\n') {
            pointX += pointSpeedX; // Обновляем X-координату мяча
            pointY += pointSpeedY; // Обновляем Y-координату мяча
        }
    }
    // После завершения этого цикла (flag = 0 или break), управление вернется в `main`,
    // которая затем начнет новую игру.
}

// --- Функция для определения движения первой ракетки ---
int f_board_key(char key, int fRStart, int fREnd, int min_pos_y, int max_pos_y) {
    if (key == 'a' && fRStart > min_pos_y) // 'a' для движения вверх (и не выходить за верхнюю границу)
        return -1; // Возвращаем -1 для движения вверх
    // 'z' для движения вниз (и не выходить за нижнюю границу)
    // max_pos_y - 2 - это последняя Y-координата, доступная для нижней части ракетки
    if (key == 'z' && fREnd < max_pos_y - 2)
        return 1; // Возвращаем 1 для движения вниз
    return 0; // Нет допустимого движения
}

// --- Функция для определения движения второй ракетки ---
int second_board_key(char key, int sRStart, int sREnd, int min_pos_y, int max_pos_y) {
    if (key == 'k' && sRStart > min_pos_y) // 'k' для движения вверх
        return -1;
    if (key == 'm' && sREnd < max_pos_y - 2) // 'm' для движения вниз
        return 1;
    return 0;
}